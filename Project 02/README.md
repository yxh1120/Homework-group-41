Rho attack
=
Rho方法是一种在密码学中常用的攻击方法，用于寻找散列函数的碰撞（两个不同的输入产生相同的散列值）。这种方法通常用于分析和破解密码算法。

![image](https://github.com/yxh1120/Homework-group-41/blob/main/Project%2002/3.png)

**实验简介：**  
首先利用Python实现了简化的sm3算法，通过对随机生成的固定长度的字符串进行sm3加密，对加密的结果进行rho attack攻击，为了展示运行效果，只让找到8bit的碰撞进行演示，由于是自己编写的sm3算法，在效率上可能达不到最理想的情况。

**实验步骤：**  
1.选择一个起始点x和一个用于计算下一个序列项的函数f(x)。通常选择f(x) = (x^2 + 1) % n，其中%表示取模运算。初始化y和d，其中y是通过f(x)计算出来的第二个序列项，d是一个辗转相除法（gcd）的中间结果，默认将d设置为1。  
2.在一个循环中，重复执行以下步骤，直到找到非平凡因子（即d != 1）或者算法失败（d == n）：  
        （1）更新x为f(x)的结果。  
        （2）更新y为f(f(y))的结果，即连续两次应用f函数。  
        （3）计算|x - y|的绝对值，并利用gcd函数求得|x - y|与n的最大公约数。  
        （4）如果最大公约数d等于n，表示算法失败，无法找到非平凡因子。  
        （5）在循环结束后，根据d的值判断算法的结果。  
3.如果d等于n，表示算法失败，无法找到非平凡因子。否则，d是n的一个非平凡因子。

**基本原理：**  
Rho方法基于定义：找到两个不同的输入x和y，使得它们经过散列函数处理后生成相同的散列值H(x) = H(y)。
Rho方法使用迭代的方式来寻找碰撞。它从一个初始的随机输入开始，然后通过重复应用散列函数来生成一系列的中间值。
迭代过程中，Rho方法使用两个指针（或者称为快指针和慢指针）在中间值序列中移动。快指针每次移动两步，而慢指针每次移动一步。
当快指针和慢指针指向相同的值时，即快指针追上或追过慢指针时，我们可以认为已经找到了一个环（Loop）。这是因为在碰撞发生之前，快指针和慢指针可能会经过相同的中间值，形成了一个循环路径。
一旦找到环，我们可以在该环上进行进一步的计算和分析，以找到碰撞点。一般来说，找到碰撞点意味着我们找到了两个不同的输入，它们经过散列函数处理后生成了相同的散列值。

关键代码实现如下：  
![image](https://github.com/yxh1120/Homework-group-41/blob/main/Project%2002/2.png)

测试结果如图所示：  
![image](https://github.com/yxh1120/Homework-group-41/blob/main/Project%2002/1.png)

运行速度：  
找到8bit的rho attack攻击大约需要消耗0.4秒

实验环境：  

