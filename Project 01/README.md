Birthday attack
=

**实验简介：**  
首先利用Python实现了简化的sm3算法，通过对随机生成的固定长度的字符串进行sm3加密，对加密的结果进行birthday攻击，为了展示运行效果，只让找到前4bit的碰撞进行演示，由于是自己编写的sm3算法，在效率上可能达不到最理想的情况。

**步骤：**    
1.随机在2^(n/2)信息空间中寻找一个M  
2.求出相应的tag  
3.寻找是否有碰撞，没有则返回步骤1  

**生日攻击原理：**  
由此我们可以将它用在碰撞，得到不同Message有着相同tag。
假设：取样次数为N，M：M1-Mn，取值在tag：1-B中，并且假设分布随机均匀相互独立。
取样次数n与B的关系，n=1.2*B^0.5（这是生日悖论中最坏的情况。）
证明：M2不等于M1的概率为(B-1)/B，同理可得M3为(B-2)/B，M4为(B-3)/B...Mn为(B-n+1)/B。
因此，其中有碰撞的概率为：1-（1-1/B）(1-2/B）.....(1-(k-1)/B）>= (1-e)^(-n^2/2B)
因为n=1.2*B^0.5，因此(1-e)^(-n^2/2B)=1-e^-0.72=0.53>50%  
因此使用生日攻击，我们只需2^(n/2)次寻找，就有50%概率能找到相同tag的两个不同Message。

关键代码如下：  
![image](https://github.com/yxh1120/Homework-group-41/blob/main/Project%2001/2.png)

测试实验结果如下图所示：  
![image](https://github.com/yxh1120/Homework-group-41/blob/main/Project%2001/1.png)

运行速度：
测试找到前4bit的碰撞约需要0.5秒。

实验环境：
IDLE (Python 3.10 64-bit)
